'use strict';

require('./chunk-1d702382.js');
require('events');
require('child_process');
var path = require('path');
require('fs');
var index = require('./chunk-e982b35b.js');
require('os');
var ensureError = require('./chunk-ec31973d.js');
require('util');
var installOp = require('./chunk-07be731c.js');
require('constants');
require('stream');
require('assert');
var getDocument = require('./chunk-5e01ad59.js');
var rethrowAsync = require('./chunk-7262e635.js');
require('https');
require('zlib');
var require$$0 = require('crypto');

async function gitDiffFiles(props) {
  const result = await ensureError.spawnAndCheck('git', ['diff', '--no-index', '--color', '--', props.fileTheirs, props.fileOurs], {
    verbosity: props.verbosity,
    expectedExitCodes: [0, 1]
  });
  return result.trim();
}

function findSingleFile(file, items) {
  const title = path.basename(file);
  const filtered = items.filter(item => {
    var _item$overview;

    return title === (item === null || item === void 0 ? void 0 : (_item$overview = item.overview) === null || _item$overview === void 0 ? void 0 : _item$overview.title);
  });

  if (filtered.length === 0) {
    return null;
  }

  if (filtered.length > 1) {
    throw new Error(`More than one document with title '${title}' found: [${filtered.map(item => `"${item.uuid}"`).join(', ')}]`);
  }

  return filtered[0];
}

async function validateFile(file, items, deps = {
  stat: installOp.lib.stat
}) {
  const result = await deps.stat(file);

  if (!result.isFile()) {
    throw new Error(`file at path '${file}' is not a file`);
  }

  return findSingleFile(file, items);
}

async function diffFile(props, file, compareUuid, deps = {
  getDocument: getDocument.getDocument,
  createFile: installOp.lib.createFile,
  unlink: installOp.lib.unlink,
  gitDiffFiles
}) {
  var _props$verbosity;

  const verbosity = (_props$verbosity = props === null || props === void 0 ? void 0 : props.verbosity) !== null && _props$verbosity !== void 0 ? _props$verbosity : 0;
  const fileTheirs = `${file}.orig.${require$$0.randomBytes(8).toString('hex')}`;
  await rethrowAsync.rethrowAsync(() => compareUuid ? deps.getDocument({
    verbosity,
    outputFilePath: fileTheirs,
    uuid: compareUuid,
    ...(props.vault && {
      vault: props.vault
    })
  }) : deps.createFile(fileTheirs), errInfo => errInfo.withMessage(`Cannot download previous version of "${file}" from 1-Password`));
  const diff = await deps.gitDiffFiles({
    fileOurs: file,
    fileTheirs,
    verbosity
  });
  await rethrowAsync.rethrowAsync(() => deps.unlink(fileTheirs), errInfo => errInfo.withMessage(`Cannot delete original version of file "${file}" at "${fileTheirs}". Please delete it manually.`));

  if (!diff) {
    console.log(`# No changes for "${file}"`);
  } else {
    console.log(diff);
  }
}

async function vaultDiff(props, deps = {
  listItems: ensureError.listItems,
  stat: installOp.lib.stat,
  unlink: installOp.lib.unlink,
  getDocument: getDocument.getDocument,
  createFile: installOp.lib.createFile,
  gitDiffFiles
}) {
  var _props$verbosity2;

  // tslint:disable-next-line: strict-boolean-expressions
  if (!props || typeof props !== 'object') {
    throw new TypeError('no properties passed');
  }

  if (typeof props.vault !== 'undefined' && typeof props.vault !== 'string') {
    throw new TypeError('vault should be a string');
  }

  if (typeof props.verbosity !== 'undefined' && (typeof props.verbosity !== 'number' || ![0, 1, 2].includes(props.verbosity))) {
    throw new TypeError('verbosity should be a number: 0, 1 or 2');
  }

  if (!Array.isArray(props.files) || props.files.length === 0) {
    throw new TypeError('files should be a non-empty array of strings');
  }

  const verbosity = (_props$verbosity2 = props === null || props === void 0 ? void 0 : props.verbosity) !== null && _props$verbosity2 !== void 0 ? _props$verbosity2 : 0;
  const items = await rethrowAsync.rethrowAsync(() => deps.listItems({
    verbosity,
    ...(props.vault && {
      vault: props.vault
    })
  }), errInfo => errInfo.withMessage('Cannot list items in 1-Password vault'));
  const filesAndItems = await Promise.all(props.files.map(file => validateFile(file, items, {
    stat: deps.stat
  }).then(item => ({
    file,
    uuid: item === null || item === void 0 ? void 0 : item.uuid
  }))));

  const logAndContinue = err => {
    console.error(err.message);
    return Promise.resolve();
  };

  await filesAndItems.reduce((prev, next) => prev.catch(logAndContinue).then(() => diffFile(props, next.file, next.uuid, {
    getDocument: deps.getDocument,
    unlink: deps.unlink,
    createFile: deps.createFile,
    gitDiffFiles: deps.gitDiffFiles
  })), Promise.resolve());
}

const program = new index.commander.Command();
const parsed = program.description('Compare one or more local checked-out files with their original 1-Password versions').exitOverride(err => {
  if (err.message === '(outputHelp)') {
    return;
  }

  program.outputHelp();
  process.exit(err.exitCode);
}).option('-v --vault <vault-name>', 'vault to use').requiredOption('-f --files <title>', 'list of files to compare', (next, previous) => {
  return [...(previous || []), next];
}).option('--verbosity <0|1|2>', 'verbosity of stdout', (next, previous) => {
  if (typeof previous !== 'undefined') {
    throw new Error('Verbosity can be specified only once');
  }

  if (!['0', '1', '2'].includes(next)) {
    throw new Error('verbosity can be only 0, 1 or 2');
  }

  return parseInt(next, 10);
}).parse(process.argv);

async function run() {
  await vaultDiff({
    vault: parsed.vault,
    files: parsed.files,
    verbosity: parsed.verbosity
  });
}

run().then(() => {
  process.exitCode = 0;
}).catch(err => {
  console.error(err.message);
  process.exitCode = 1;
});
