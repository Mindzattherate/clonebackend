'use strict';

require('./chunk-1d702382.js');
require('events');
require('child_process');
var path = require('path');
require('fs');
var index = require('./chunk-e982b35b.js');
require('os');
var ensureError = require('./chunk-ec31973d.js');
var util = require('util');
require('./chunk-07be731c.js');
require('constants');
require('stream');
require('assert');
var getDocument = require('./chunk-5e01ad59.js');
var rethrowAsync = require('./chunk-7262e635.js');
var catchAsync = require('./chunk-31f10cfd.js');
require('https');
require('zlib');
require('crypto');

async function processFile(props, file, items, deps = {
  getDocument: getDocument.getDocument
}) {
  var _props$verbosity;

  const title = path.basename(file);
  const filtered = items.filter(item => {
    var _item$overview;

    return title === (item === null || item === void 0 ? void 0 : (_item$overview = item.overview) === null || _item$overview === void 0 ? void 0 : _item$overview.title);
  });

  if (filtered.length === 0) {
    throw new Error(`No document with title '${file}' found`);
  }

  if (filtered.length > 1) {
    throw new Error(`More than one document with title '${file}' found`);
  }

  const verbosity = (_props$verbosity = props === null || props === void 0 ? void 0 : props.verbosity) !== null && _props$verbosity !== void 0 ? _props$verbosity : 0;
  return await rethrowAsync.rethrowAsync(() => deps.getDocument({
    verbosity,
    uuid: filtered[0].uuid,
    outputFilePath: file,
    ...(props.vault && {
      vault: props.vault
    }),
    ...(typeof props.force === 'boolean' && {
      force: props.force
    })
  }), errInfo => errInfo.withMessage('Cannot download document from 1-Password vault'));
}

async function vaultCheckout(props,
/**
 * @ignore
 */
deps = {
  listItems: ensureError.listItems,
  getDocument: getDocument.getDocument
}) {
  var _props$verbosity2;

  // tslint:disable-next-line: strict-boolean-expressions
  if (!props || typeof props !== 'object') {
    throw new TypeError('no properties passed');
  }

  if (typeof props.vault !== 'undefined' && typeof props.vault !== 'string') {
    throw new TypeError('vault should be a string');
  }

  if (typeof props.force !== 'undefined' && typeof props.force !== 'boolean') {
    throw new TypeError('force should be a boolean');
  }

  if (!Array.isArray(props.files) || props.files.length === 0) {
    throw new TypeError('files should be a non-empty array of strings');
  }

  const verbosity = (_props$verbosity2 = props.verbosity) !== null && _props$verbosity2 !== void 0 ? _props$verbosity2 : 0;
  const items = await rethrowAsync.rethrowAsync(() => deps.listItems({ ...(props.vault && {
      vault: props.vault
    }),
    verbosity
  }), errInfo => errInfo.withMessage('Cannot list items in 1-Password vault'));
  const results = await Promise.all(props.files.map(file => catchAsync.catchAsync(() => processFile(props, file, items, {
    getDocument: deps.getDocument
  }))));
  const errorResults = results.map(item => item.error).filter(util.isError);

  if (errorResults.length > 0) {
    if (errorResults.length > 1) {
      const [first, ...rest] = errorResults;
      throw new ensureError.AggregateError(first, ...rest);
    } else {
      throw errorResults[0];
    }
  }
}

const program = new index.commander.Command();
const parsed = program.description('Download one or more files from 1-Password vault to current directory').exitOverride(err => {
  if (err.message === '(outputHelp)') {
    return;
  }

  program.outputHelp();
  process.exit(err.exitCode);
}).option('-v --vault <vault-name>', 'vault to use').option('--force', 'overwrite existing files', false).requiredOption('-f --files <title>', 'list of files to checkout', (next, previous) => {
  return [...(previous || []), next];
}).option('--verbosity <0|1|2>', 'verbosity of stdout', (next, previous) => {
  if (typeof previous !== 'undefined') {
    throw new Error('Verbosity can be specified only once');
  }

  if (!['0', '1', '2'].includes(next)) {
    throw new Error('verbosity can be only 0, 1 or 2');
  }

  return parseInt(next, 10);
}).parse(process.argv);

async function run() {
  await vaultCheckout({
    vault: parsed.vault,
    files: parsed.files,
    force: parsed.force,
    verbosity: parsed.verbosity
  });
}

run().then(() => {
  process.exitCode = 0;
}).catch(err => {
  console.error(err.message);
  process.exitCode = 1;
});
